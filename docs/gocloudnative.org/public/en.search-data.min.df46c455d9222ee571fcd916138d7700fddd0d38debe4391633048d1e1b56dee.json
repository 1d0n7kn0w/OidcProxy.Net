[{"id":0,"href":"/table-of-content/","title":"Table of Content","section":"GoCloudNative.BFF - Documentation","content":" Documentation # Table of contents # Concepts API authorization with OAuth2/OpenId Connect What is Authorization Code with Proof Key for Code Exchange? What is a Back-end For Front-End? What is a Reverse Proxy? Distributed apps Horizontal scaling Architecture The BFF Security Pattern The GoCloudNative.BFF.Authentication software-architecture Horizontal scaling/scaling out Extensibility (implementing custom identity providers) Aggregating responses from multiple downstream endpoints Integration Manuals Quickstarts Auth0 Azure Active Directory IdentityServer4 KeyCloak Migrating an Angular Single Page Application with an API Infrastructure Distributed apps Applying a BFF in an Azure Container Apps environment Applying a BFF in Kubernetes "},{"id":1,"href":"/concepts/api-authorization/","title":"API Authorization with OAuth2/OpenId Connect","section":"Concepts","content":" API Authorization with OAuth2/OpenId Connect # OAuth2 is an authorization protocol. It is meant to be used to grant or deny access to resources. OpenId Connect extends the OAuth2 protocol. OpenId Connect (OIDC) is an identity protocol. It emits the identity of either a person or a machine.\nAn important aspect of both OAuth2 and OIDC is that both protocols authenticate a person decentrally. This allows the application landscape which uses an OAuth2- or an OIDC-server to scale.\nTo get the benefits that go with decentralized authentication, there are certain concepts to keep in mind when you\u0026rsquo;re implementing authorization in an API:\nUse the OIDC-server for authentication purposes Make sure the OIDC-server is application agnostic Apply policies Do not store Personal Identifyable Information in your APIs Implications # The OpenId Connect protocol is built in such a way that it solves a number of common authentication- and authorization problems. If you want to profit from this, keep in mind the following things when you implement authorization in your API:\nIdentity and Access Management # Implementing authorization in an API is means to an end. When you are implementing OIDC-based authentication, you\u0026rsquo;re delegating the responsibility to authenticate users to another application.\nDelegating this responsiblity comes with a risk. The more the OIDC-server \u0026ldquo;knows\u0026rdquo; about another application, the harder it gets to release the two. Also, when more application\u0026rsquo;s are \u0026lsquo;born\u0026rsquo;, the OIDC-server will have to store more and more data. This does not scale well.\nTherefor, as a common rule of thumb, try to reduce what the OIDC-server knows about other applications to a minimum. Stick to common OIDC-claims as much as you can.\nExample: Common scenario\u0026rsquo;s to avoid:\nImplementing application-specific roles like \u0026ldquo;crm_admin\u0026rdquo; Creating application-specific claims like \u0026ldquo;is_crm_admin\u0026rdquo; And so forth Examples: Instead do this:\nrole: \u0026ldquo;hr_secretary\u0026rdquo;, applications may decide what authorization applies for users in such a role. PII # An OIDC server exchanges identity-information with an application through access- and id-tokens. These tokens contain Personal Identifyable Information. When the front-end uses the id_token to display a user\u0026rsquo;s name, for example, and when the back-end uses nothing but roles, user-ids, and scopes, then there is no need for an API to store Personal Identifyable Information.\nAs a result, Personal Identifyable Information is always in one place: The OIDC Server. This is very convenient when you want to be GDPR-compliant.\nHow to implement authorization in your API # So, to implement authorization in a scalable, safe way, make sure to do the following:\nDo not include the id_token in API requests Include the access_token in the request to an API Use the information int he access_token to apply a policy. Do not build your own authorization middleware, instead use Microsoft.AspNetCore.Authentication. Given an API does not have a user interface, it does not care how the consumer of the API obtained an access_token. All it should care about is if it is a valid token. So, in your program.cs, implement the following code:\n.NET 6:\nusing Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.IdentityModel.Tokens; var builder = WebApplication.CreateBuilder(args); // ... builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(\u0026#34;Bearer\u0026#34;, options =\u0026gt; { options.Authority = \u0026#34;https://login.yourdomain.com\u0026#34;; options.TokenValidationParameters = new TokenValidationParameters { //.. }; }); // ... var app = builder.Build(); // ... app.UseAuthorization(); // ... app.Run(); And decorate the endpoints in your controllers as such:\n.NET 6:\n[ApiController] [Route(\u0026#34;api/test\u0026#34;)] public class WeatherForecastController : ControllerBase { [HttpGet] [Authorize] // Use this attribute to enforce authentication public IActionResult Get() { var user = this.User.Identity as ClaimsIdentity; return Ok($\u0026#34;Hello, {user.Name}!\u0026#34;); } } Find a sample implementation here.\nAdvanced authorization scenario\u0026rsquo;s # Sometimes, the information stored in the access_token is not sufficient to determine whether someone is authorized to access a resource or not. In that case, you need to enritch the context, so you can apply a policy on the information from the access_token combined with application specific information.\nEnritching the context as such is called claims-transformation. This can be applied by implementing the IClaimsTransformation interface:\nusing Microsoft.AspNetCore.Authentication; using System.Security.Claims; public class MyClaimsTransformation : IClaimsTransformation { public Task\u0026lt;ClaimsPrincipal\u0026gt; TransformAsync(ClaimsPrincipal principal) { ClaimsIdentity claimsIdentity = new ClaimsIdentity(); var claimType = \u0026#34;myNewClaim\u0026#34;; if (!principal.HasClaim(claim =\u0026gt; claim.Type == claimType)) { claimsIdentity.AddClaim(new Claim(claimType, \u0026#34;myClaimValue\u0026#34;)); } principal.AddIdentity(claimsIdentity); return Task.FromResult(principal); } } Register the middleware in program.cs as follows:\nbuilder.Services.AddTransient\u0026lt;IClaimsTransformation, MyClaimsTransformation\u0026gt;(); To apply a custom policy on this claim, implement policy-based authorization by adding the following code-snippet to program.cs:\nbuilder.Services.AddAuthorization(o =\u0026gt; { o.AddPolicy(\u0026#34;onlyMyNewClaim\u0026#34;, p =\u0026gt; p.RequireClaim(\u0026#34;myNewClaim\u0026#34;, \u0026#34;myClaimValue\u0026#34;)); }); And apply the policy in your controller:\n[HttpGet] [Authorize(\u0026#34;onlyMyNewClaim\u0026#34;)] public IActionResult Get() { return Ok(\u0026#34;I am authorized!\u0026#34;); } Even more advanced scenario\u0026rsquo;s # As an alternative you may consider implementing Open Policy Agent.\nSummary # Use OpenId for authentication-purposes. Apply a policy in each individual API to determine whether or not the consumer of the API is authorized.\nSources # https://abstarreveld.medium.com/claims-transformation-in-net-6-483c30705e12 https://learn.microsoft.com/en-us/aspnet/core/security/authentication/claims?view=aspnetcore-6.0#extend-or-add-custom-claims-using-iclaimstransformationcore-6.0 https://learn.microsoft.com/en-us/aspnet/core/security/authorization/policies?view=aspnetcore-7.0 "},{"id":2,"href":"/concepts/","title":"Concepts","section":"GoCloudNative.BFF - Documentation","content":""},{"id":3,"href":"/integration-manuals/quickstarts/auth0/quickstart/","title":"Implementing the BFF Security Pattern with Auth0","section":"Integration-manuals","content":" Implementing the BFF Security Pattern with Auth0 # Complete the following three steps to implement the BFF Security Pattern with Auth0:\nConfigure Auth0. Create an aspnetcore API Build a BFF Step 1.) Configure Auth0 # The GoCloudNatibe.Bff only supports the Authorization Code Flow with Proof Key for Client Exchange. That\u0026rsquo;s why it is important to configure Auth0 in a specific way.\nFollow these steps to configure Auth0 correctly:\nGo to https://manage.auth0.com and sign in\nGo to the Applications section in the menu on the left-hand side and click Applications\nClick + Create application in the right upper corner\nProvide a name for your app and select Regular web applications\nNow, click settings, now you\u0026rsquo;ll see the following section: Copy the client_id, the secret, and the authority into the appsettings.json, like so:\n{ ... \u0026#34;Auth0\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;iuw4kjwkj34kj3\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;kjh423j43jkh43jk2443jhsdfgs345te4th\u0026#34;, \u0026#34;Domain\u0026#34;: \u0026#34;example.eu.auth0.com\u0026#34;, \u0026#34;Audience\u0026#34;: \u0026#34;https://example.eu.auth0.com/api/v2\u0026#34;, \u0026#34;Scopes\u0026#34;: [ \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;offline_access\u0026#34; ] } ... } Now, configure the redirecturl. When the user has logged into Auth0, Auth0 will redirect the user to this URL. Redirecting will not work unless the redirect URL has been whitelisted: Next, scroll to the Advanced settings and configure the grant_types. Enable Authorization Code and Refresh tokens Step 2.) Build the aspnetcore API # Create a new project:\ndotnet new webapi dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer Create the following Program.cs file:\nusing System.Security.Claims; using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.IdentityModel.Tokens; var builder = WebApplication.CreateBuilder(args); builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(options =\u0026gt; { options.Authority = $\u0026#34;https://{builder.Configuration[\u0026#34;Auth0:Domain\u0026#34;]}/\u0026#34;; options.Audience = builder.Configuration[\u0026#34;Auth0:Audience\u0026#34;]; options.TokenValidationParameters = new TokenValidationParameters { NameClaimType = ClaimTypes.NameIdentifier }; }); builder.Services.AddControllers(); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Make sure you have configured Auth0 in your appsettings.json file:\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;Auth0\u0026#34;: { \u0026#34;Domain\u0026#34;: \u0026#34;{yourDomain}\u0026#34;, \u0026#34;Audience\u0026#34;: \u0026#34;{yourApiIdentifier}\u0026#34; }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } In this example, we assume you\u0026rsquo;re running this API on port 8080. To get this API to run on that port, modify your LaunchSettings.json file to like like so:\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;http\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;launchUrl\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;applicationUrl\u0026#34;: \u0026#34;http://localhost:8080\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } Step 3.) Build the BFF # To build a BFF with aspnet core, execute the following commands on the command line:\ndotnet new web dotnet add package GoCloudNative.Bff.Authentication.Auth0 Create the following Program.cs file:\nusing GoCloudNative.Bff.Authentication.Auth0; using GoCloudNative.Bff.Authentication.ModuleInitializers; var builder = WebApplication.CreateBuilder(args); builder.Services.AddSecurityBff(o =\u0026gt; { o.ConfigureAuth0(builder.Configuration.GetSection(\u0026#34;Auth0\u0026#34;)); o.LoadYarpFromConfig(builder.Configuration.GetSection(\u0026#34;ReverseProxy\u0026#34;)); }); var app = builder.Build(); app.UseRouting(); app.UseSecurityBff(); app.Run(); Create the following appsettings.json file:\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;Auth0\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;{yourClientId}\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;{yourClientSecret}\u0026#34;, \u0026#34;Domain\u0026#34;: \u0026#34;{yourDomain}\u0026#34;, \u0026#34;Audience\u0026#34;: \u0026#34;{yourAudience}\u0026#34;, \u0026#34;FederatedLogout\u0026#34;: false, \u0026#34;Scopes\u0026#34;: [ \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;offline_access\u0026#34; ] }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;spa\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;spa\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/{*any}\u0026#34; } }, \u0026#34;api\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/api/{*any}\u0026#34; } }, }, \u0026#34;Clusters\u0026#34;: { \u0026#34;spa\u0026#34;: { \u0026#34;Destinations\u0026#34;: { \u0026#34;spa\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;http://localhost:4200/\u0026#34; } } }, \u0026#34;api\u0026#34;: { \u0026#34;Destinations\u0026#34;: { \u0026#34;api\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;http://localhost:8080/\u0026#34; } } }, } } } Use the following Properties/launchSettings.json, this launchSettings file ensures the application url matches the callback url that has been configured in Auth0:\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;https\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:8443\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } In this example we assume you are running a Single Page Application on localhost on port 4200 and you have an API running at localhost on port 8080. If that is not the case, then update the appsettings.json accordingly.\nTo run the BFF, type dotnet run or just hit the \u0026lsquo;play\u0026rsquo;-button in Visual Studio. When you run the BFF, make sure to have your API and your SPA running too.\nEndpoints # The BFF relays all requests as configured in the ReverseProxy section in the appsettings.json file, except for four endpoints:\n[GET] /account/login # To log a user in and to start a http session, navigate to /account/login. The software will redirect to the login page of the Identity Provider to log the user in. The resulting tokens will be stored in the user session and are not available in the browser.\n[GET] /account/login/callback # This endpoint is used by the IdentityProvider.\n[GET] /account/me # To see the logged in user, navigate to the /account/me endpoint. This endpoint shows the claims that are in the id_token.\n[GET] /account/end-session # To revoke the tokens that have been obtained when the user logged in, navigate to /account/end-session endpoint. This will revoke the tokens that have been stored in the user session. This will also end the user-session on at the Identity Provider\nDemo # Check out a fully working demo here.\nIssues # Are you encountering issues? Please let us know at: https://github.com/thecloudnativewebapp/GoCloudNative.Bff/issues\n"},{"id":4,"href":"/integration-manuals/quickstarts/identityserver4/quickstart/","title":"Implementing the BFF Security Pattern with IdentityServer4","section":"Integration-manuals","content":" Implementing the BFF Security Pattern with IdentityServer4 # Complete the following three steps to implement the BFF Security Pattern with IdentityServer4:\nConfigure IdentityServer. Create an aspnetcore API Build a BFF Step 1.) Configure IdentityServer4 # The GoCloudNatibe.Bff only supports the Authorization Code Flow with Proof Key for Client Exchange. That\u0026rsquo;s why it is important to configure IdentityServer in a specific way. Configure the Client as follows:\npublic static readonly Client Client = new Client { // Set the ClientId and the ClientSecret ClientId = \u0026#34;bff\u0026#34;, ClientSecrets = { new Secret(\u0026#34;secret\u0026#34;.Sha256()) }, // Configure the Authorization Code flow with PKCE AllowedGrantTypes = GrantTypes.Code, RequirePkce = true, // Configure the access token lifetime (1h by default) AccessTokenLifetime = 3600, // Make sure IdentityServer may redirect to the bff RedirectUris = { \u0026#34;https://localhost:8443/account/login/callback\u0026#34; }, FrontChannelLogoutUri = \u0026#34;https://localhost:8443/\u0026#34;, PostLogoutRedirectUris = { \u0026#34;https://localhost:8443/\u0026#34; }, // Enable offline access, the BFF needs it to refresh the tokens // after they expire. Otherwise the session would end after 1h. AllowOfflineAccess = true, // Add the profile claims to the id token so they are available // in the /account/me endpoint of the BFF. AlwaysIncludeUserClaimsInIdToken = true, AllowedScopes = { IdentityServerConstants.StandardScopes.OpenId, IdentityServerConstants.StandardScopes.Profile, IdentityServerConstants.StandardScopes.Email, // .. other scopes } }; Find a sample identity-server implementation here: https://github.com/thecloudnativewebapp/GoCloudNative.Bff/tree/main/docs/Integration-Manuals/Integrating-With-Identity-Providers/IdentityServer4/src/IdentityServer4\nStep 2.) Build the aspnetcore API # Create a new project:\ndotnet new webapi dotnet add package Microsoft.AspNetCore.Authentication.JwtBearer Create the following Program.cs file:\nusing System.Security.Claims; using Microsoft.AspNetCore.Authentication.JwtBearer; using Microsoft.IdentityModel.Tokens; var builder = WebApplication.CreateBuilder(args); builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme) .AddJwtBearer(\u0026#34;Bearer\u0026#34;, options =\u0026gt; { options.Authority = builder.Configuration[\u0026#34;Oidc:Authority\u0026#34;]; options.TokenValidationParameters = new TokenValidationParameters { ValidateAudience = false }; }); builder.Services.AddControllers(); var app = builder.Build(); app.UseHttpsRedirection(); app.UseAuthorization(); app.MapControllers(); app.Run(); Make sure you have configured IdentityServer in your appsettings.json file:\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;Oidc\u0026#34;: { \u0026#34;Authority\u0026#34;: \u0026#34;https://{yourAuthority}\u0026#34; }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34; } In this example, we assume you\u0026rsquo;re running this API on port 8080. To get this API to run on that port, modify your LaunchSettings.json file to like like so:\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;http\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;launchUrl\u0026#34;: \u0026#34;/\u0026#34;, \u0026#34;applicationUrl\u0026#34;: \u0026#34;http://localhost:8080\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } Step 3.) Build the BFF # To build a BFF with aspnet core, execute the following commands on the command line:\ndotnet new web dotnet add package GoCloudNative.Bff.Authentication.OpenIdConnect Create the following Program.cs file:\nusing GoCloudNative.Bff.Authentication.OpenIdConnect; using GoCloudNative.Bff.Authentication.ModuleInitializers; var builder = WebApplication.CreateBuilder(args); builder.Services.AddSecurityBff(o =\u0026gt; { o.ConfigureOpenIdConnect(builder.Configuration.GetSection(\u0026#34;Oidc\u0026#34;)); o.LoadYarpFromConfig(builder.Configuration.GetSection(\u0026#34;ReverseProxy\u0026#34;)); }); var app = builder.Build(); app.UseRouting(); app.UseSecurityBff(); app.Run(); Create the following appsettings.json file:\n{ \u0026#34;Logging\u0026#34;: { \u0026#34;LogLevel\u0026#34;: { \u0026#34;Default\u0026#34;: \u0026#34;Information\u0026#34;, \u0026#34;Microsoft.AspNetCore\u0026#34;: \u0026#34;Warning\u0026#34; } }, \u0026#34;Oidc\u0026#34;: { \u0026#34;ClientId\u0026#34;: \u0026#34;{yourClientId}\u0026#34;, \u0026#34;ClientSecret\u0026#34;: \u0026#34;{yourClientSecret}\u0026#34;, \u0026#34;Authority\u0026#34;: \u0026#34;https://{yourAuthority}\u0026#34;, \u0026#34;Scopes\u0026#34;: [ \u0026#34;openid\u0026#34;, \u0026#34;profile\u0026#34;, \u0026#34;offline_access\u0026#34; ] }, \u0026#34;AllowedHosts\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;ReverseProxy\u0026#34;: { \u0026#34;Routes\u0026#34;: { \u0026#34;spa\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;spa\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/{*any}\u0026#34; } }, \u0026#34;api\u0026#34;: { \u0026#34;ClusterId\u0026#34;: \u0026#34;api\u0026#34;, \u0026#34;Match\u0026#34;: { \u0026#34;Path\u0026#34;: \u0026#34;/api/{*any}\u0026#34; } }, }, \u0026#34;Clusters\u0026#34;: { \u0026#34;spa\u0026#34;: { \u0026#34;Destinations\u0026#34;: { \u0026#34;spa\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;http://localhost:4200/\u0026#34; } } }, \u0026#34;api\u0026#34;: { \u0026#34;Destinations\u0026#34;: { \u0026#34;api\u0026#34;: { \u0026#34;Address\u0026#34;: \u0026#34;http://localhost:8080/\u0026#34; } } }, } } } Use the following Properties/launchSettings.json, this launchSettings file ensures the application url matches the callback url that has been configured in IdentityServer:\n{ \u0026#34;profiles\u0026#34;: { \u0026#34;https\u0026#34;: { \u0026#34;commandName\u0026#34;: \u0026#34;Project\u0026#34;, \u0026#34;dotnetRunMessages\u0026#34;: true, \u0026#34;launchBrowser\u0026#34;: true, \u0026#34;applicationUrl\u0026#34;: \u0026#34;https://localhost:8443\u0026#34;, \u0026#34;environmentVariables\u0026#34;: { \u0026#34;ASPNETCORE_ENVIRONMENT\u0026#34;: \u0026#34;Development\u0026#34; } } } } In this example we assume you are running a Single Page Application on localhost on port 4200 and you have an API running at localhost on port 8080. If that is not the case, then update the appsettings.json accordingly.\nTo run the BFF, type dotnet run or just hit the \u0026lsquo;play\u0026rsquo;-button in Visual Studio. When you run the BFF, make sure to have your API and your SPA running too.\nEndpoints # The BFF relays all requests as configured in the ReverseProxy section in the appsettings.json file, except for four endpoints:\n[GET] /account/login # To log a user in and to start a http session, navigate to /account/login. The software will redirect to the login page of the Identity Provider to log the user in. The resulting tokens will be stored in the user session and are not available in the browser.\n[GET] /account/login/callback # This endpoint is used by the IdentityProvider.\n[GET] /account/me # To see the logged in user, navigate to the /account/me endpoint. This endpoint shows the claims that are in the id_token.\n[GET] /account/end-session # To revoke the tokens that have been obtained when the user logged in, navigate to /account/end-session endpoint. This will revoke the tokens that have been stored in the user session. This will also end the user-session on at the Identity Provider\nDemo # Check out a fully working demo here.\nIssues # Are you encountering issues? Please let us know at: https://github.com/thecloudnativewebapp/GoCloudNative.Bff/issues\n"},{"id":5,"href":"/integration-manuals/","title":"Integration-manuals","section":"GoCloudNative.BFF - Documentation","content":""}]